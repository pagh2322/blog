---
category: DB
tags: AWS, DynamoDB
date: 2024-07-26
---

## NoSQL

### 탄생 배경

- 기존의 RDBMS이 개발되었던 시점에서는 CPU보다 스토리지 비용이 비쌌기에 정규화를 통해 중복 데이터를 최소화 함
    - 효율적인 스토리지 사용에 집중
- 하지만 스토리지 비용이 저렴해지고, 대규모 연산을 처리해야 하는 상황이 많아짐
    - **데이터 중복을 감안하여 빠르게 처리하는 것에 집중**

### 특징

- 스키마 변경 유연
- 스케일링에 용이
- …

## DynamoDB

### 특징

- Key-Value 형태의 NoSQL
- 리전 당 테이블을 5000개 까지 생성 가능 (추가 요청 가능)
- 낙관적 락 기법을 활용한 분산 락
- TTL(Time To Live) 설정 가능 (WCU 소모 x)
- 읽기 및 쓰기 용량 단위로 비용 부과
    - WCU
        - 최대 1KB 항목의 쓰기 용량 단위 하나는 초당 쓰기 하나를 나타낸다.
        - 항목이 1KB보다 크면 더 많은 WCU가 사용된다. (1KB 씩 up)
    - RCU
        - 읽기 용량 단위 1개에 대해
            - 4KB 크기의 항목에 대해서 초당 **강력한 일관된 읽기** 1개
            - 4KB 크기의 항목에 대해서 초당 **최종적 일관된 읽기** 2개
        - 항목이 4KB보다 크면 더 많은 RCU가 사용된다. (4KB 씩 up)
- 비용
    - 테이블 당 25GB까지 무료, 이후 GB 당 월 0.27075 USD
    - 온디맨드 기준
        - 읽기(RCU, 4KB) 100만건 당 0.271 USD
        - 쓰기(WCU, 1KB) 100만건 당 1.3556 USD
    - 프로비저닝 기준
        - WCU 시간당 0.0007049 USD
        - RCU 시간당 0.00014098 USD

### 기본 개념

- 테이블과 파티션
    - 테이블
        
        
        | user_id | name | age | height | hobby |
        | --- | --- | --- | --- | --- |
        | USER#326 | John | 24 | 187 |  |
        | USER#173 | Helena | 28 | 169 | movie |
        | USER#852 | Ben | 38 |  | running |
        - 테이블 크기에 대한 제한 없음
            - 테이블에는 무한 개의 아이템(항목 or 행)을 가짐
            - 아이템은 여러 개의 속성을 가짐
        - 아이템 하나의 최대 크기는 400KB (속성 이름 포함)
            - 모든 아이템의 속성 이름과 값을 함께 스토리지에 저장하기 때문에 속성 이름을 줄여서 쓰는 것을 권장
                - 예: `last_login_time` → `llt`
        - Primary Key는 테이블 생성 시 결정되며, 하나의 아이템을 식별함
    - 파티션
        
        DynamoDB는 테이블이라는 논리적인 공간 내부에 다수의 파티션이 서로 다른 물리적인 공간에 위치한다. 각 파티션은 가용성을 위해 일반적으로 **3개의 스토리지 노드 혹은 서버로 복제(Replication)**이 진행된다. 각 노드는 서로 다른 AZ에 위치한다.
        
        - 3개의 노드 중 하나는 Leader 노드이며, **쓰기 작업을 담당**한다.
        - 나머지 2개의 노드는 Follower 노드이며, **Leader 노드로부터 각각 동기, 비동기 복제**를 진행한다. (각각 동기 Follower 노드, 비동기 Follower 노드라고 칭함)
            - **Health Check**: Leader 노드는 주기적으로 Follower 노드에게 Heartbeat를 보낸다.
            - **새 Leader 노드를 선정**: Leader 노드로부터 Heartbeat를 받지 못하면 Paxos 합의 알고리즘을 통해 새로운 Leader 노드를 선정한다.
        - 쓰기 작업은 Leader 노드와 하나의 동기 Follower 노드가 작업에 성공해야 성공으로 인정한다.
            - 비동기 Follower 노드는 **비동기로 쓰기 작업을 반영**하기에 최종적 일관적이다.
                - 이유: 최종 시점엔 모든 노드가 쓰기 작업을 완료하여 데이터가 일관적이기 때문
- 읽기 모드
    
    파티션은 하나의 Leader 노드와 2개의 Follower 노드로 존재한다.
    
    - **쓰기 요청을 수행**하는 Leader 노드는 항상 최신 데이터를 유지
    
    DynamoDB에서 제공하는 읽기 모드는 다음과 같다.
    
    - 최종적 일관된 읽기 (기본)
        
        읽기 요청을 전달받으면 Leader 노드와 Follower 노드 중 하나에서 랜덤으로 읽어오기 때문에 최신 데이터가 없을 수 있는 Follower 노드로부터 요청 전달 시 예전 데이터를 받을 수 있음
        
        - 최대 4KB 크기 아이템의 하나의 읽기 요청 시 0.5 RCU 소모
    - 강력한 일관된 읽기
        
        읽기 요청은 Leader 노드에서 읽어오기 때문에 항상 최신 데이터를 받을 수 있음
        
        - 최종적 일관된 읽기보다 더 많은 시간 소모
        - 최대 4KB 크기 아이템의 하나의 읽기 요청 시 1 RCU 소모
- 용량 모드
    
    2개의 모드가 존재하며 서로 간의 전환은 무중단으로 하루에 한번 가능하다.
    
    - On-demand: 요청한 만큼만 비용 부가. 특정 기간에만 테이블을 많이 사용할 경우 적합.
        - 워크로드에 따라 자동으로 읽기/쓰기 확장/축소
        - 용량 계획 불필요
        - 사용량에 대한 비용 지불
        - 사용 사례
            - 알 수 없는 워크로드
            - 예측할 수 없는 트래픽
    - Provisioned(기본): 상시로 직접 설정한 RCU/WCU로 요청 처리. 트래픽이 예측 가능할 경우 적합.
        - 사전에 초당 읽기/쓰기 수를 지정
            - 테이블에 RCU/WCU가 미리 설정되어야 하며, 설정한만큼 비용 지불
        - 수요에 맞게 처리량의 자동 확장을 설정하는 옵션 제공
        
        테이블을 생성할 때 RCU와 WCU를 지정해야 하며, 설정한 값을 초과하는 요청들이 들어올 경우 스로틀링이 발생할 수 있다.
        
        ![테이블 내부에는 균등하게 용량이 할당된 파티션이 존재](https://prod-files-secure.s3.us-west-2.amazonaws.com/e9ce54d6-0556-4225-86a1-564c207b03c4/d5b3cc75-1ad8-46a6-a227-8c732bee4bcd/Untitled.png)
        
        테이블 내부에는 균등하게 용량이 할당된 파티션이 존재
        
        테이블에 대해 설정된 RCU와 WCU는 **파티션 간에 균등하게 분배**된다. 만약 특정 파티션이 할당받은 것보다 높은 트래픽을 받는 경우 그 파티션으로의 요청이 제한(스로틀링)된다.
        

### 아키텍처

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e9ce54d6-0556-4225-86a1-564c207b03c4/5677e7a2-1b36-4ce4-935f-dd8d7ce25b3a/Untitled.png)

DynamoDB에서는 모든 요청을 Request Router에 보낸다. Request Router는 두 가지 컴포넌트와 상호작용 후 실제 데이터가 있는 스토리지 노드에 접근하게 된다.

1. Authentication System: AWS 플랫폼에서 공통으로 사용되는 권한 확인 컴포넌트
    - 전달받은 요청자가 권한이 있거나 인증되었는지 검증
        - JSON 기반 정책을 참고하여 해당 요청자는 어떤 Action이 허용되었는지 검증
2. Partition Metadata System: 파티션 정보를 관리해, Request Router가 요청을 보낼 노드를 선정
    - 내부적으로 Auto Admin이 동작
        - **데이터 증가에 따른 파티셔닝** 및 인덱스 관리
3. Storage Node: 파티션의 Leader 노드와 Follower 노드를 관리
    - 각 AZ마다 다수의 스토리지 노드 존재
4. Global Admission Control(GAC): 요청 처리(RCU/WCU)를 위해 사용되는 토큰 용량을 관리
    - 파티션/테이블이 처리하려는 요청의 수만큼 실제로 처리할 자격(Admission)이 있는지 검증
        - 처리할 수 있는지에 대한 자격 여부는 해당 파티션에 할당된 토큰 개수를 통해 판단 가능

## 요청 처리와 스로틀링

- Token Bucket 알고리즘
    
    ![여러 AWS 서비스에서 스로틀링을 구현하기 위해 사용되는 Token Bucket 알고리즘](https://prod-files-secure.s3.us-west-2.amazonaws.com/e9ce54d6-0556-4225-86a1-564c207b03c4/59f9c8e2-9b88-427e-827f-d54cc6726b74/Untitled.png)
    
    여러 AWS 서비스에서 스로틀링을 구현하기 위해 사용되는 Token Bucket 알고리즘
    
    원리는 다음과 같다.
    
    1. 각 파티션마다 버킷을 할당
    2. 각 버킷은 매 초마다 프로비저닝된 RCU/WCU를 기반으로 토큰을 생성
        - 버킷의 용량을 초과하면 토큰은 버려짐
        - throttle burst: 버킷의 용량은 동시에 실행할 수 있는 요청의 수를 의미
        - throttle rate: 토큰이 생성되는 속도는 초당 처리할 수 있는 요청의 수를 의미
    3. 버킷에서 토큰을 소모하여 읽기/쓰기 요청 수행
    4. 만약 버킷이 초당 허용된 토큰을 모두 소진하면, DynamoDB는 `ProvisionedThroughputExceededException`를 발생
- Adaptive Capacity
    
    프로비저닝된 처리량보다 더 많은 요청이 들어오는 파티션을 핫 파티션(Hot Partition)이라 부르며, 이를 처리하기 위한 기법은 Bursting과 Adaptive Capacity가 있다.
    
    - Bursting: 프로비저닝되었지만 과거에 사용하지 않았던 Unit을 약 5분동안 누적하고 있다가 필요할 때 소진 기법
    - 하지만 일시적으로 동작하기 때문에 시간이 길어지게 되면 Adaptive Capacity 기법을 사용해야 함
        - 모든 DynamoDB 테이블에 기본적으로 적용됨
    
    ![핫 파티션에 대한 요청을 실패없이 처리하도록 노력한다.](https://prod-files-secure.s3.us-west-2.amazonaws.com/e9ce54d6-0556-4225-86a1-564c207b03c4/e98c8a7f-455d-4ae5-9396-a9346808ad0b/Untitled.png)
    
    핫 파티션에 대한 요청을 실패없이 처리하도록 노력한다.
    
    각 파티션 별로 Capacity Unit이 균등 분배되는 문제가 발생하여 한 파티션으로 Read/Write가 집중될 경우 스로틀링(`ProvisionedThroughputExceededException`)이 발생할 수 있다. 이를 어느정도 해결하기 위해 Adaptive Capacity를 도입했는데, **다른 파티션의 사용하지 않는 Capacity Unit을 끌어와서 사용**하는 기법이다.
    
    1. **모니터링**: Adaptive Capacity는 모든 테이블의 프로비저닝된 용량과 소비된 용량을 모니터링한다.
    2. **용량 조정**: 만약 특정 테이블에서 스로틀링이 발생하고 테이블의 처리량이 초과되지 않았을 경우, 자동으로 스로틀링이 발생하는 파티션에 할당된 처리량을 증가시킨다.
- Global Admission Control(GAC)
    
    Adaptive Capacity의 문제점은 스로틀링이 감지되어야만 동작한다는 점이다. 따라서 기존에 커플링되어 있던 **토큰 용량 관리 로직**과 **요청 처리 제어 로직**을 분리하기 위해 GAC가 등장했다.
    
    - GAC는 **테이블 단위로 소모하는 토큰 용량을 모니터링**한다.
    - Request Router는 **로컬 토큰 버킷을 유지하여 요청 처리를 제어**하며 **GAC와 주기적으로 소통하여 토큰을 요구한다**.
    
    Request Router는 로컬 토큰 버킷을 전부 사용했다면 GAC로부터 더 많은 토큰을 요구하고, GAC는 요구 정보와 모니터링하는 테이블의 토큰 용량을 고려해서 가능한만큼 토큰을 대여해준다.
    

## 샤딩(파티션 분할)

파티션이 사용하는 RCU/WCU가 많아지거나, 크기가 일정 수준 이상 커지면 내부적으로 해당 파티션에 대해서 샤딩을 진행한다.

- 파티션 하나당 **3000 RCU 및 1000 WCU** 만큼의 요청을 처리할 수 있다.
    - 요청 초과 시 샤딩
- 파티션 크기 **10GB 초과** 시 샤딩

트래픽이 높은 특정 아이템은 별도의 파티션으로 자동 분리된다.

- 이유: 해당 아이템을 위해 사용하는 RCU/WCU 때문에 같은 파티션의 다른 아이템이 성능 상 손해를 입기 때문

일반적인 해시 기법을 사용하면 파티션 샤딩 시 **해시 재배치**가 발생한다.

- 서버 풀의 개수 고정 시, `serverIndex = hash(key) % N`를 사용하여 부하를 균등하게 나눈다.
    - 문제: 서버의 개수 변경으로 인해 `serverIndex`가 변경되고, 대량의 데이터 이동으로 인한 오버헤드가 발생
        
        
        | Key | serverIndex(N = 10) | serverIndex(N = 11) |
        | --- | --- | --- |
        | 1567 | 7 | 5 |
        | 2354 | 4 | 0 |
        | 2888 | 8 | 6 |

(**Dynamo 기준**) 샤딩을 하면서 발생되는 데이터 이동은 일관된 해시(Consistent Hash)를 통해 시간을 최소화한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e9ce54d6-0556-4225-86a1-564c207b03c4/9230cfef-1c75-4672-811d-e9b6bd4a0c1e/Untitled.png)

일관된 해시은 분산 시스템에서 데이터를 균등하게 분산하기 위한 기법이다. **재배치를 최소화**하며, 노드(서버)의 변경에 독립적으로 동작한다.

1. 키 공간을 가상의 원형 공간으로 표현하는 해시 링을 형성한 후, 데이터가 분산 저장될 노드는 해시 링에 존재한다.
    - 노드가 추가/제거되면 해당 노드와 인접한 노드들만 데이터를 재분배됨
2. 데이터는 해시 값을 통해 알맞는 노드에 저장되며, 해시 값이 동일한 노드가 없으면 시계 방향으로 가장 가까운 노드에 저장된다.

새로 추가된 노드는 링에 알맞는 위치에 배치된 뒤, **새 노드와 인접한 키에 대한 데이터들만 변경**하면 되기 때문에 재배치를 최소화할 수 있다.

하지만 현재 DynamoDB는 일관된 해시를 사용하지 않는다. (추측으로는) 대신 Partition Metadata System에서 테이블 라우팅 정보를 관리하고(Partition Map), Request Router는 해당 정보를 캐싱 후 알맞는 파티션을 찾아 요청을 전달하는 **마이크로서비스**로 구현되어있다.

- 파티션 샤딩 시, 기존 파티션에 있던 데이터의 절반이 생성된 파티션으로 이동

**Partition Map**

| Hash Range | Partition |
| --- | --- |
| 0x0000..0x6FFF | [Partition1, Partition3] |
| 0x7000..0xBFFF | [Partition2, Partition5] |
| 0xC000..0xFFFF | [Partition4] |

**Partition1**

| Hash | Attributes |
| --- | --- |
| 0x12A8 | { name: “Bob”, city: “London” } |
| 0x6134 | { name: “Alex”, city: “Seattle” } |